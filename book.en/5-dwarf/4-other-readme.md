We have mentioned DIE in section 5.3, which is used for describling variables, data types, executable code like functions and compilation unit, etc. Besides DIE, Dwarf also has other important data that is heavily dependent on for symbolic level debuggers.

This data includes:

- Accelerated Access

  A debugger frequently needs to find the debugging information for a program entity by a name, type, or address. When producer generating DWARF debugging information, DWARF allows compilers generating three more tables to accelerate the query process, table .debug_pubnames for lookup by name for data objects and functions, .debug_pubtypes for lookup by name for types, .debug_aranges for lookup by address.

- Line Number Table 

  The Dwarf line number table contains the mapping between the memory address of executable code of a program and the source lines that corresponds to these address. 

- Macro Information 

  Most debuggers have a very difficult time displaying and debugging code which has macros. The user sees the original source file, with the macros, while the code corresponds to whatever the macros generated. 

  Dwarf includes the description of the macros defined in the progam. This is quite rudimentary information, but can be used by a debugger to display the values for a macro or possibly translate the macro into the corresponding source language. 

- Call Frame Information 

  Every processor has a certain **way of determining how to pass parameters and return values**, this is defined by the **processor’s ABI (Application Binary Interface)**. 

  Dwarf call frame information (CFI) provides the debugger enough information about how a function is called, how to locate the parameters to the functions, how to locate the call frame for the calling function. This information is used by the debugger to unwind the stack, locating the previous function, the location where the function is called, and the values passed. 

- Variable Length Data 

  Integer values are used throughout Dwarf to represent everything from offsets into data sections to sizes of arrays or structures. Since most values can be represented in only a few bits, this means that the data consists mostly of zeros. 

  Dwarf defines a variable length integer, called Little Endian Base 128 (LEB128 for signed integers or ULEB128 for unsigned integers), which compresses the bytes taken up to represent the integers.  

  Wiki: https://en.wikipedia.org/wiki/LEB128 

- Shrinking Dwarf data

  The encoding schemes used by Dwarf significantly reduce the size of the debugging information compared to the Dwarf v1. But unfortunately, many programs’ debugging information generated by compilers still can be very large, frequently larger than the executable code and data. 

  Dwarf offers ways to further reduce the size of the debugging data. This part could be neglected here for now, as far as I am concerned. 

- ELF Sections

  While Dwarf is defined in a way that allows it to be used with any object file format, it’s most often used with ELF.  

  Each of the different kinds of Dwarf data are stored in their own section. The names of these sections all start with prefix ‘.debug_’, for example, .debug_frame contains call frame info, .debug_info contains core dwarf data like DIEs, .debug_types contains the definitions of data types, .debug_line contains the line number program (sequence of instructions to generate the complete line number table).